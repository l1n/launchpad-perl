.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ALSA 3"
.TH ALSA 3 "2014-04-16" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIDI::ALSA \- the ALSA library, plus some interface functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\& use MIDI::ALSA(\*(Aq:CONSTS\*(Aq);
\& MIDI::ALSA::client( \*(AqPerl MIDI::ALSA client\*(Aq, 1, 1, 0 );
\& MIDI::ALSA::connectfrom( 0, 14, 0 );  # input port is lower (0)
\& MIDI::ALSA::connectto( 1, 20, 0 );   # output port is higher (1)
\& while (1) {
\&     my @alsaevent = MIDI::ALSA::input();
\&     if ($alsaevent[0] == SND_SEQ_EVENT_PORT_UNSUBSCRIBED()) { last; }
\&     if ($alsaevent[0] == SND_SEQ_EVENT_NOTEON()) {
\&         my $channel  = $alsaevent[7][0];
\&         my $pitch    = $alsaevent[7][1];
\&         my $velocity = $alsaevent[7][2];
\&     } elsif ($alsaevent[0] == SND_SEQ_EVENT_CONTROLLER()) {
\&         my $channel    = $alsaevent[7][0];
\&         my $controller = $alsaevent[7][4];
\&         my $value      = $alsaevent[7][5];
\&     }
\&     MIDI::ALSA::output( @alsaevent );
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module offers a Perl interface to the \fI\s-1ALSA\s0\fR library.
It is a call-compatible translation into Perl of the Lua module
\&\fImidialsa\fR http://www.pjb.com.au/comp/lua/midialsa.html
which is in turn based on the Python modules
\&\fIalsaseq.py\fR and \fIalsamidi.py\fR by Patricio Paez.
.PP
It also offers some functions to translate events from and to
the event format used in Sean Burke's MIDI-Perl module.
.PP
Nothing is exported by default,
but all the functions and constants can be exported, e.g.:
 use \s-1MIDI::ALSA\s0(client, connectfrom, connectto, id, input, output);
 use \s-1MIDI::ALSA\s0(':CONSTS');
.PP
As from version 1.15, note durations are in seconds rather
than milliseconds, for consistency with the timestamps.
This introduces a backward incompatibility which only affects
you if are putting together your own alsaevents without using the
\&\fInoteevent()\fR function.  In the worst case you have to detect versions:
.PP
.Vb 1
\& if ($MIDI::ALSA::VERSION < 1.145) { $alsevent[7][4] *= 1000; }
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Functions based on those in \fIalsaseq.py\fR:
\&\fIclient()\fR, \fIconnectfrom()\fR, \fIconnectto()\fR, \fIdisconnectfrom()\fR, \fIdisconnectto()\fR, \fIfd()\fR,
\&\fIid()\fR, \fIinput()\fR, \fIinputpending()\fR, \fIoutput()\fR, \fIstart()\fR, \fIstatus()\fR, \fIstop()\fR, \fIsyncoutput()\fR
.PP
Functions based on those in \fIalsamidi.py\fR:
\&\fInoteevent()\fR, \fInoteonevent()\fR, \fInoteoffevent()\fR, \fIpgmchangeevent()\fR,
\&\fIpitchbendevent()\fR, \fIcontrollerevent()\fR, \fIchanpress()\fR, \fIsysex()\fR
.PP
Functions to interface with \fIMIDI-Perl\fR:
\&\fIalsa2scoreevent()\fR, \fIscoreevent2alsa()\fR
.PP
Functions to get the current \s-1ALSA\s0 status:
\&\fIlistclients()\fR, \fIlistnumports()\fR, \fIlistconnectedto()\fR, \fIlistconnectedfrom()\fR,
\&\fIparse_address()\fR
.ie n .IP "client($name, $ninputports, $noutputports, $createqueue)" 3
.el .IP "client($name, \f(CW$ninputports\fR, \f(CW$noutputports\fR, \f(CW$createqueue\fR)" 3
.IX Item "client($name, $ninputports, $noutputports, $createqueue)"
Create an \s-1ALSA\s0 sequencer client with zero or more input or output ports,
and optionally a timing queue.  ninputports and noutputports are created
if the quantity requested is between 1 and 64 for each.
If \fIcreatequeue\fR = true, it creates a queue for stamping the arrival time
of incoming events and scheduling future start times of outgoing events.
.Sp
For full \s-1ALSA\s0 functionality, the \fI\f(CI$name\fI\fR
should contain only letters, digits, underscores or spaces,
and should contain at least one letter.
.Sp
Unlike in the \fIalsaseq.py\fR Python module, it returns success or failure.
.ie n .IP "connectfrom( $inputport, $src_client, $src_port )" 3
.el .IP "connectfrom( \f(CW$inputport\fR, \f(CW$src_client\fR, \f(CW$src_port\fR )" 3
.IX Item "connectfrom( $inputport, $src_client, $src_port )"
Connect from \fIsrc_client:src_port\fR to \fIinputport\fR. Each input port can
connect from more than one client. The \fIinput\fR() function will receive events
from any intput port and any of the clients connected to each of them.
Events from each client can be distinguised by their source field.
.Sp
Unlike in the \fIalsaseq.py\fR Python module, it returns success or failure.
.Sp
Since version 1.11, and unlike in the \fIalsaseq.py\fR Python module,
if \f(CW$src_client\fR contains a letter or \f(CW$src_port\fR is undefined,
then \fIparse_address($src_client)\fR automatically gets invoked.
This allows you to refer to the clients by name, for example
connectfrom($inputport,'Virtual:1') will connect from
port 1 of the 'Virtual Raw \s-1MIDI\s0' client.
.ie n .IP "connectto( $outputport, $dest_client, $dest_port )" 3
.el .IP "connectto( \f(CW$outputport\fR, \f(CW$dest_client\fR, \f(CW$dest_port\fR )" 3
.IX Item "connectto( $outputport, $dest_client, $dest_port )"
Connect \fIoutputport\fR to \fIdest_client:dest_port\fR.
Each output port can be Connected to more than one client.
Events sent to an output port using the \fIoutput\fR()  funtion
will be sent to all clients that are connected to it using this function.
.Sp
Unlike in the \fIalsaseq.py\fR Python module, it returns success or failure.
.Sp
Since version 1.11, and unlike in the \fIalsaseq.py\fR Python module,
if \f(CW$dest_client\fR contains a letter or \f(CW$dest_port\fR is undefined,
then \fIparse_address($dest_client)\fR automatically gets invoked.
This allows you to refer to the clients by name, for example
connectto($outputport,'Virtual:1') will connect to
port 1 of the 'Virtual Raw \s-1MIDI\s0' client.
.ie n .IP "disconnectfrom( $inputport, $src_client, $src_port )" 3
.el .IP "disconnectfrom( \f(CW$inputport\fR, \f(CW$src_client\fR, \f(CW$src_port\fR )" 3
.IX Item "disconnectfrom( $inputport, $src_client, $src_port )"
Disconnect the connection
from the remote \fIsrc_client:src_port\fR to my \fIinputport\fR.
Returns success or failure.
.Sp
Since version 1.11, and unlike in the \fIalsaseq.py\fR Python module,
if \f(CW$dest_client\fR contains a letter or \f(CW$dest_port\fR is undefined,
then \fIparse_address($src_client)\fR automatically gets invoked.
This allows you to refer to the clients by name, for example
disconnectfrom($inputport,'Virtual:1') will disconnect from
port 1 of the 'Virtual Raw \s-1MIDI\s0' client.
.ie n .IP "disconnectto( $outputport, $dest_client, $dest_port )" 3
.el .IP "disconnectto( \f(CW$outputport\fR, \f(CW$dest_client\fR, \f(CW$dest_port\fR )" 3
.IX Item "disconnectto( $outputport, $dest_client, $dest_port )"
Disconnect the connection
from my \fIoutputport\fR to the remote \fIdest_client:dest_port\fR.
Returns success or failure.
.Sp
Since version 1.11, and unlike in the \fIalsaseq.py\fR Python module,
if \f(CW$dest_client\fR contains a letter or \f(CW$dest_port\fR is undefined,
then \fIparse_address($dest_client)\fR automatically gets invoked.
This allows you to refer to the clients by name, for example
disconnectto($outputport,'Virtual:1') will disconnect to
port 1 of the 'Virtual Raw \s-1MIDI\s0' client.
.IP "\fIfd()\fR" 3
.IX Item "fd()"
Return fileno of sequencer.
.Sp
This piece of code, contributed by Daren Schwenke,
uses the \fIAnyEvent\fR module to build an application which waits
both for \s-1ALSA\s0 events, and for user-input:
.Sp
.Vb 7
\&   my $alsa_midi = AnyEvent\->io (
\&      fh => MIDI::ALSA::fd(), poll => "r",
\&      cb => sub {
\&         my @alsaevent = MIDI::ALSA::input();
\&         print "Alsa event: " . Dumper(\e@alsaevent);
\&      }
\&   );
.Ve
.IP "\fIid()\fR" 3
.IX Item "id()"
Return the client number, or 0 if the client is not yet created.
.IP "\fIinput()\fR" 3
.IX Item "input()"
Wait for an \s-1ALSA\s0 event in any of the input ports and return it.
\&\s-1ALSA\s0 events are returned as an array with 8 elements:
.Sp
.Vb 1
\& ($type, $flags, $tag, $queue, $time, \e@source, \e@destination, \e@data)
.Ve
.Sp
Unlike in the \fIalsaseq.py\fR Python module,
the time element is in floating-point seconds.
The last three elements are also arrays:
.Sp
.Vb 3
\& @source = ( $src_client,  $src_port )
\& @destination = ( $dest_client,  $dest_port )
\& @data = ( varies depending on type )
.Ve
.Sp
The \fIsource\fR and \fIdestination\fR arrays may be useful within an application
for handling events differently according to their source or destination.
The event-type constants, beginning with \s-1SND_SEQ_,\s0
are available as module subroutines with empty prototypes,
not as strings, and must therefore be used without any dollar-sign e.g.:
.Sp
.Vb 1
\& if ($event[0] == MIDI::ALSA::SND_SEQ_EVENT_PORT_UNSUBSCRIBED) { ...
.Ve
.Sp
Note that if the event is of type \s-1SND_SEQ_EVENT_PORT_SUBSCRIBED\s0
or \s-1SND_SEQ_EVENT_PORT_UNSUBSCRIBED,\s0
then that message has come from the System,
and its \fIdest_port\fR tells you which of your ports is involved.
But its \fIsrc_client\fR and \fIsrc_port\fR do not tell you which other client
disconnected;  you'll need to use \fI\fIlistconnectedfrom()\fI\fR
or \fI\fIlistconnectedto()\fI\fR to see what's happened.
.Sp
The data array is mostly as documented in
http://alsa\-project.org/alsa\-doc/alsa\-lib/seq.html.
For \s-1NOTE\s0 events,  the elements are
( \f(CW$channel\fR, \f(CW$pitch\fR, \f(CW$velocity\fR, unused, \f(CW$duration\fR );
where since version 1.15 the \fIduration\fR is in floating-point seconds
(unlike in the \fIalsaseq.py\fR Python module where it is in milliseconds).
For \s-1SYSEX\s0 events, the data array contains just one element:
the byte-string, including any F0 and F7 bytes.
For most other events,  the elements are
($channel, unused,unused,unused, \f(CW$param\fR, \f(CW$value\fR)
.Sp
The \fIchannel\fR element is always 0..15
.IP "\fIinputpending()\fR" 3
.IX Item "inputpending()"
Return the number of bytes available in input buffer.
Use before \fIinput()\fR  to wait till an event is ready to be read. 
If a connection terminates, then \fIinputpending()\fR returns,
and the next event will be of type \s-1SND_SEQ_EVENT_PORT_UNSUBSCRIBED\s0
.IP "output($type,$flags,$tag,$queue,$time,\e@source,\e@destination,\e@data)" 3
.IX Item "output($type,$flags,$tag,$queue,$time,@source,@destination,@data)"
Send an ALSA-event from an output port.
The format of the event is as discussed in \fIinput()\fR above.
The event will be output immediately
either if no queue was created in the client
or if the \fIqueue\fR parameter is set to \s-1SND_SEQ_QUEUE_DIRECT,\s0
and otherwise it will be queued and scheduled.
.Sp
The \fI\f(CI@source\fI\fR is an array with two elements: ($src_client, \f(CW$src_port\fR),
specifying the local output-port from which the event will be sent.
If only one output-port exists, all events are sent from it.
If two or more exist, the \fI\f(CI$src_port\fI\fR determines which to use.
The smallest available port-number (as created by \fIclient\fR())
will be used if \fI\f(CI$src_port\fI\fR is less than it,
and the largest available will be used if \fI\f(CI$src_port\fI\fR is greater than it.
.Sp
The \fI\f(CI@destination\fI\fR is an array with two elements: ($dest_client, \f(CW$dest_port\fR),
specifying the remote client/port to which the event will be sent.
If \fI\f(CI$dest_client\fI\fR is zero
(as generated by \fI\fIscoreevent2alsa()\fI\fR or \fI\fInoteevent()\fI\fR),
or is the same as the local client
(as generated by \fI\fIinput()\fI\fR),
then the event will be sent to all clients that the local port is connected to
(see \fIconnectto\fR() and \fI\fIlistconnectedto()\fI\fR).
But if you set \fIdest_client\fR to a remote client,
then the event will be sent to that
\&\fIdest_client:dest_port\fR and nowhere else.
.Sp
It is possible to send an event to a destination to which there
is no connection, but it's not usually
the right thing to do. Normally, you should set up a connection,
to allow the underlying RawMIDI ports to remain open while
playing \- otherwise, \s-1ALSA\s0 will reset the port after every event.
.Sp
If the queue buffer is full, \fIoutput\fR() will wait
until space is available to output the event.
Use \fIstatus\fR() to know how many events are scheduled in the queue.
.Sp
If no queue has been started, a \s-1SND_SEQ_EVENT_NOTE\s0 event
can only emerge as a \s-1SND_SEQ_EVENT_NOTEON,\s0 since a queue
is necessary in order to schedule the corresponding \s-1NOTEOFF.\s0
.IP "\fIstart()\fR" 3
.IX Item "start()"
Start the queue. It is ignored if the client does not have a queue.
.IP "\fIstatus()\fR" 3
.IX Item "status()"
Return ($status,$time,$events ) of the queue.
.Sp
.Vb 3
\& Status: 0 if stopped, 1 if running.
\& Time: current time in seconds.
\& Events: number of output events scheduled in the queue.
.Ve
.Sp
If the client does not have a queue then (0,0,0) is returned.
Unlike in the \fIalsaseq.py\fR Python module,
the \fItime\fR element is in floating-point seconds.
.IP "\fIstop()\fR" 3
.IX Item "stop()"
Stop the queue. It is ignored if the client does not have a queue.
.IP "\fIsyncoutput()\fR" 3
.IX Item "syncoutput()"
Wait until output events are processed.
.ie n .IP "noteevent( $ch, $key, $vel, $start, $duration )" 3
.el .IP "noteevent( \f(CW$ch\fR, \f(CW$key\fR, \f(CW$vel\fR, \f(CW$start\fR, \f(CW$duration\fR )" 3
.IX Item "noteevent( $ch, $key, $vel, $start, $duration )"
Returns an ALSA-event-array, to be scheduled by \fIoutput\fR().
Unlike in the \fIalsaseq.py\fR Python module,
the \fIstart\fR and \fIduration\fR elements are in floating-point seconds.
.ie n .IP "noteonevent( $ch, $key, $vel, $start )" 3
.el .IP "noteonevent( \f(CW$ch\fR, \f(CW$key\fR, \f(CW$vel\fR, \f(CW$start\fR )" 3
.IX Item "noteonevent( $ch, $key, $vel, $start )"
If \fIstart\fR is not used, the event will be sent directly.
Unlike in the \fIalsaseq.py\fR Python module.
if \fIstart\fR is provided, the event will be scheduled in a queue. 
The \fIstart\fR element, when provided, is in floating-point seconds.
.ie n .IP "noteoffevent( $ch, $key, $vel, $start )" 3
.el .IP "noteoffevent( \f(CW$ch\fR, \f(CW$key\fR, \f(CW$vel\fR, \f(CW$start\fR )" 3
.IX Item "noteoffevent( $ch, $key, $vel, $start )"
If \fIstart\fR is not used, the event will be sent directly.
Unlike in the \fIalsaseq.py\fR Python module,
if \fIstart\fR is provided, the event will be scheduled in a queue. 
The \fIstart\fR element, when provided, is in floating-point seconds.
.ie n .IP "pgmchangeevent( $ch, $value, $start )" 3
.el .IP "pgmchangeevent( \f(CW$ch\fR, \f(CW$value\fR, \f(CW$start\fR )" 3
.IX Item "pgmchangeevent( $ch, $value, $start )"
Returns an ALSA-event-array for a \fIpatch_change\fR event
to be sent by \fIoutput\fR().
If \fIstart\fR is not used, the event will be sent directly;
if \fIstart\fR is provided, the event will be scheduled in a queue. 
Unlike in the \fIalsaseq.py\fR Python module,
the \fIstart\fR element, when provided, is in floating-point seconds.
.ie n .IP "pitchbendevent( $ch, $value, $start )" 3
.el .IP "pitchbendevent( \f(CW$ch\fR, \f(CW$value\fR, \f(CW$start\fR )" 3
.IX Item "pitchbendevent( $ch, $value, $start )"
Returns an ALSA-event-array to be sent by \fIoutput\fR().
The value is from \-8192 to 8191.
If \fIstart\fR is not used, the event will be sent directly;
if \fIstart\fR is provided, the event will be scheduled in a queue. 
Unlike in the \fIalsaseq.py\fR Python module,
the \fIstart\fR element, when provided, is in floating-point seconds.
.ie n .IP "controllerevent( $ch, $controllernum, $value, $start )" 3
.el .IP "controllerevent( \f(CW$ch\fR, \f(CW$controllernum\fR, \f(CW$value\fR, \f(CW$start\fR )" 3
.IX Item "controllerevent( $ch, $controllernum, $value, $start )"
Returns an ALSA-event-array to be sent by \fIoutput\fR().
If \fIstart\fR is not used, the event will be sent directly;
if \fIstart\fR is provided, the event will be scheduled in a queue. 
Unlike in the \fIalsaseq.py\fR Python module,
the \fIstart\fR element, when provided, is in floating-point seconds.
.ie n .IP "chanpress( $ch, $value, $start )" 3
.el .IP "chanpress( \f(CW$ch\fR, \f(CW$value\fR, \f(CW$start\fR )" 3
.IX Item "chanpress( $ch, $value, $start )"
Returns an ALSA-event-array to be sent by \fIoutput\fR().
If \fIstart\fR is not used, the event will be sent directly;
if \fIstart\fR is provided, the event will be scheduled in a queue. 
Unlike in the \fIalsaseq.py\fR Python module,
the \fIstart\fR element, when provided, is in floating-point seconds.
.ie n .IP "sysex( $ch, $string, $start )" 3
.el .IP "sysex( \f(CW$ch\fR, \f(CW$string\fR, \f(CW$start\fR )" 3
.IX Item "sysex( $ch, $string, $start )"
Returns an ALSA-event-array to be sent by \fIoutput\fR().
If \fIstart\fR is not used, the event will be sent directly;
if \fIstart\fR is provided, the event will be scheduled in a queue. 
The string should start with your Manufacturer \s-1ID,\s0
but should not contain any of the F0 or F7 bytes,
they will be added automatically;
indeed the string must not contain any bytes with the top-bit set.
.ie n .IP "alsa2scoreevent( @alsaevent )" 3
.el .IP "alsa2scoreevent( \f(CW@alsaevent\fR )" 3
.IX Item "alsa2scoreevent( @alsaevent )"
Returns an event in the millisecond-tick score-format
used by the \fI\s-1MIDI\s0.lua\fR and \fI\s-1MIDI\s0.py\fR modules,
based on the score-format in Sean Burke's MIDI-Perl \s-1CPAN\s0 module. See:
 http://www.pjb.com.au/comp/lua/MIDI.html#events
.Sp
Since it combines a \fInote_on\fR and a \fInote_off\fR event into one note event,
it will return \fInil\fR when called with the \fInote_on\fR event;
the calling loop must therefore detect \fInil\fR
and not, for example, try to index it.
.ie n .IP "scoreevent2alsa( @event )" 3
.el .IP "scoreevent2alsa( \f(CW@event\fR )" 3
.IX Item "scoreevent2alsa( @event )"
Returns an ALSA-event-array to be scheduled in a queue by \fIoutput\fR().
The input is an event in the millisecond-tick score-format
used by the \fI\s-1MIDI\s0.lua\fR and \fI\s-1MIDI\s0.py\fR modules,
based on the score-format in Sean Burke's MIDI-Perl \s-1CPAN\s0 module. See:
 http://www.pjb.com.au/comp/lua/MIDI.html#events
.Sp
For example:
 output(scoreevent2alsa('note',4000,1000,0,62,110))
.Sp
Some events in a .mid file have no equivalent
real-time-midi event (which is the sort that \s-1ALSA\s0 deals in);
these events will cause \fIscoreevent2alsa()\fR to return undef.
Therefore if you are going through the events in a midi score
converting them with \fIscoreevent2alsa()\fR,
you should check that the result is not undef before doing anything further.
.IP "\fIlistclients()\fR" 3
.IX Item "listclients()"
Returns a hash of the numbers and descriptive strings of all \s-1ALSA\s0 clients:
.Sp
.Vb 2
\& my %clientnumber2clientname = MIDI::ALSA::listclients();
\& my %clientname2clientnumber = reverse %clientnumber2clientname;
.Ve
.IP "\fIlistnumports()\fR" 3
.IX Item "listnumports()"
Returns a hash of the client-numbers and how many ports they are running,
so if a client is running 4 ports they will be numbered 0..3
.Sp
.Vb 1
\& my %clientnumber2howmanyports = MIDI::ALSA::listnumports();
.Ve
.IP "\fIlistconnectedto()\fR" 3
.IX Item "listconnectedto()"
Returns a list of arrayrefs, each to a three-element array
( \f(CW$outputport\fR, \f(CW$dest_client\fR, \f(CW$dest_port\fR )
exactly as might have been passed to \fIconnectto\fR(),
or which could be passed to \fIdisconnectto\fR().
.IP "\fIlistconnectedfrom()\fR" 3
.IX Item "listconnectedfrom()"
Returns a list of arrayrefs, each to a three-element array
( \f(CW$inputport\fR, \f(CW$src_client\fR, \f(CW$src_port\fR )
exactly as might have been passed to \fIconnectfrom\fR(),
or which could be passed to \fIdisconnectfrom\fR().
.ie n .IP "parse_address( $client_name )" 3
.el .IP "parse_address( \f(CW$client_name\fR )" 3
.IX Item "parse_address( $client_name )"
Given a string, this function returns a two-integer array
( \f(CW$client_number\fR, \f(CW$port_number\fR )
as might be needed by \fIconnectto\fR() or \fIconnectfrom\fR().
For example, even if \fIclient\fR() has not been called,
\&\*(L"24\*(R" will return 24,0 and \*(L"25:1\*(R" will return 25,1
.Sp
If the local client is running, then \fIparse_address()\fR 
also looks up names. For example, if \f(CW\*(C`aconnect \-oil\*(C'\fR
reveals a \fItimidity\fR client:
.Sp
.Vb 1
\& client 128: \*(AqTiMidity\*(Aq [type=user]
.Ve
.Sp
then parse_address(\*(L"TiM\*(R") will return 128,0
and parse_address(\*(L"TiMi:1\*(R") will return 128,1
because it finds the first client with a start-of-string
case-sensitive match to the given name.
\&\fIparse_address()\fR is called automatically by \fIconnectto\fR(),
\&\fIconnectfrom\fR(), \fIdisconnectto\fR() and \fIdisconnectfrom\fR() if they are
called with the third argument undefined.
.Sp
\&\fIparse_address()\fR was introduced in version 1.11 and is not present in
the alsaseq.py Python module.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
The event-type constants, beginning with \s-1SND_SEQ_,\s0
are available not as scalars, but as module subroutines with empty prototypes.
They must therefore be used without a dollar-sign e.g.:
.PP
.Vb 1
\& if ($event[0] == MIDI::ALSA::SND_SEQ_EVENT_PORT_UNSUBSCRIBED) { ...
.Ve
.PP
and sometimes even need an explicit () at the end, e.g.:
\&\s-1\fIMIDI::ALSA::SND_SEQ_EVENT_PORT_UNSUBSCRIBED\s0()\fR
.PP
\&\s-1SND_SEQ_EVENT_BOUNCE SND_SEQ_EVENT_CHANPRESS SND_SEQ_EVENT_CLIENT_CHANGE
SND_SEQ_EVENT_CLIENT_EXIT SND_SEQ_EVENT_CLIENT_START SND_SEQ_EVENT_CLOCK
SND_SEQ_EVENT_CONTINUE SND_SEQ_EVENT_CONTROL14 SND_SEQ_EVENT_CONTROLLER
SND_SEQ_EVENT_ECHO SND_SEQ_EVENT_KEYPRESS SND_SEQ_EVENT_KEYSIGN
SND_SEQ_EVENT_NONE SND_SEQ_EVENT_NONREGPARAM SND_SEQ_EVENT_NOTE
SND_SEQ_EVENT_NOTEOFF SND_SEQ_EVENT_NOTEON SND_SEQ_EVENT_OSS
SND_SEQ_EVENT_PGMCHANGE SND_SEQ_EVENT_PITCHBEND SND_SEQ_EVENT_PORT_CHANGE
SND_SEQ_EVENT_PORT_EXIT SND_SEQ_EVENT_PORT_START SND_SEQ_EVENT_PORT_SUBSCRIBED
SND_SEQ_EVENT_PORT_UNSUBSCRIBED SND_SEQ_EVENT_QFRAME SND_SEQ_EVENT_QUEUE_SKEW
SND_SEQ_EVENT_REGPARAM SND_SEQ_EVENT_RESET SND_SEQ_EVENT_RESULT
SND_SEQ_EVENT_SENSING SND_SEQ_EVENT_SETPOS_TICK SND_SEQ_EVENT_SETPOS_TIME
SND_SEQ_EVENT_SONGPOS SND_SEQ_EVENT_SONGSEL SND_SEQ_EVENT_START
SND_SEQ_EVENT_STOP SND_SEQ_EVENT_SYNC_POS SND_SEQ_EVENT_SYSEX
SND_SEQ_EVENT_SYSTEM SND_SEQ_EVENT_TEMPO SND_SEQ_EVENT_TICK
SND_SEQ_EVENT_TIMESIGN SND_SEQ_EVENT_TUNE_REQUEST SND_SEQ_EVENT_USR0
SND_SEQ_EVENT_USR1 SND_SEQ_EVENT_USR2 SND_SEQ_EVENT_USR3
SND_SEQ_EVENT_USR4 SND_SEQ_EVENT_USR5 SND_SEQ_EVENT_USR6
SND_SEQ_EVENT_USR7 SND_SEQ_EVENT_USR8 SND_SEQ_EVENT_USR9
SND_SEQ_EVENT_USR_VAR0 SND_SEQ_EVENT_USR_VAR1 SND_SEQ_EVENT_USR_VAR2
SND_SEQ_EVENT_USR_VAR3 SND_SEQ_EVENT_USR_VAR4 SND_SEQ_QUEUE_DIRECT
SND_SEQ_TIME_STAMP_REAL VERSION\s0
.PP
The \s-1MIDI\s0 standard specifies that a \s-1NOTEON\s0 event with velocity=0 means
the same as a \s-1NOTEOFF\s0 event; so you may find a little subroutine like
this convenient:
.PP
.Vb 10
\& sub is_noteoff { my @alsaevent = @_;
\&    if ($alsaevent[0] == MIDI::ALSA::SND_SEQ_EVENT_NOTEOFF()) {
\&        return 1;
\&    }
\&    if ($alsaevent[0] == MIDI::ALSA::SND_SEQ_EVENT_NOTEON()
\&      and $alsaevent[7][2] == 0) {
\&        return 1;
\&    }
\&    return 0;
\& }
.Ve
.PP
Since Version 1.20, the output-ports are marked as \s-1WRITE,\s0
so they can receive
\&\s-1SND_SEQ_EVENT_PORT_SUBSCRIBED\s0 or \s-1SND_SEQ_EVENT_PORT_UNSUBSCRIBED\s0
events from \fISystem Announce\fR.
Up until Version 1.19, and in the original Python module,
output-ports created by \fIclient()\fR were not so marked;
in those days, if knowing about connections and disconnections to the
output-port was important, you had to listen to all notifications from
\&\fISystem Announce\fR:
\&\f(CW\*(C`MIDI::ALSA::connectfrom(0,\*(AqSystem:1\*(Aq)\*(C'\fR
This alerted you unnecessarily to events which didn't involve your client,
and the connection showed up confusingly
in the output of \f(CW\*(C`aconnect \-oil\*(C'\fR
.SH "DOWNLOAD"
.IX Header "DOWNLOAD"
This Perl version is available from \s-1CPAN\s0 at
http://search.cpan.org/perldoc?MIDI::ALSA
.PP
The Lua module is available as a LuaRock in
http://luarocks.org/repositories/rocks/index.html#midi
so you should be able to install it with the command:
 # luarocks install midialsa
.SH "TO DO"
.IX Header "TO DO"
Perhaps there should be a general \fIconnect_between()\fR mechanism,
allowing the interconnection of two other clients,
a bit like \fIaconnect 32 20\fR
.PP
\&\s-1ALSA\s0 does not transmit Meta-Events like \fItext_event\fR,
and there's not much can be done about that.
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter J Billam, http://www.pjb.com.au/comp/contact.html
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 10
\& aconnect \-oil
\& http://pp.com.mx/python/alsaseq
\& http://search.cpan.org/perldoc?MIDI::ALSA
\& http://www.pjb.com.au/comp/lua/midialsa.html
\& http://luarocks.org/repositories/rocks/index.html#midialsa
\& http://www.pjb.com.au/comp/lua/MIDI.html
\& http://www.pjb.com.au/comp/lua/MIDI.html#events
\& http://alsa\-project.org/alsa\-doc/alsa\-lib/seq.html
\& http://alsa\-project.org/alsa\-doc/alsa\-lib/structsnd_\|_seq_\|_ev_\|_note.html
\& http://alsa\-project.org/alsa\-doc/alsa\-lib/structsnd_\|_seq_\|_ev_\|_ctrl.html
\& http://alsa\-project.org/alsa\-doc/alsa\-lib/structsnd_\|_seq_\|_ev_\|_queue_\|_control.html
\& http://alsa\-project.org/alsa\-doc/alsa\-lib/group_\|_\|_seq_client.html
\& http://alsa\-utils.sourcearchive.com/documentation/1.0.20/aconnect_8c\-source.html 
\& http://alsa\-utils.sourcearchive.com/documentation/1.0.8/aplaymidi_8c\-source.html
\& snd_seq_client_info_event_filter_clear
\& snd_seq_get_any_client_info
\& snd_seq_get_client_info
\& snd_seq_client_info_t
\& http://hackage.haskell.org/package/alsa\-seq
\& http://search.cpan.org/perldoc?AnyEvent
.Ve
